#!/usr/bin/env bash
# Simple tmux session and process listing

# Parse arguments
COMPACT_MODE=false
WATCH_MODE=false
INTERVAL=2

while [[ $# -gt 0 ]]; do
    case "$1" in
        --compact|-c)
            COMPACT_MODE=true
            shift
            ;;
        --watch|-w)
            WATCH_MODE=true
            # Check if next arg is a number (interval)
            if [[ "$2" =~ ^[0-9]+$ ]]; then
                INTERVAL="$2"
                shift
            fi
            shift
            ;;
        --help|-h)
            echo "Usage: tmux-ps [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  -c, --compact         Show only high-resource processes (yellow/red)"
            echo "  -w, --watch [N]       Refresh every N seconds (default: 2)"
            echo "  -h, --help            Show this help message"
            echo ""
            echo "Examples:"
            echo "  tmux-ps                    # Show all processes once"
            echo "  tmux-ps --compact          # Show only problem processes"
            echo "  tmux-ps --watch            # Refresh every 2 seconds"
            echo "  tmux-ps -w 5 -c            # Compact mode, refresh every 5s"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Run 'tmux-ps --help' for usage information"
            exit 1
            ;;
    esac
done

# Trap Ctrl+C for clean exit
trap 'echo ""; exit 0' INT

# Function to recursively get all descendant PIDs
get_all_descendants() {
    local parent_pid=$1
    local descendants=""

    # Get direct children
    local children=$(pgrep -P "$parent_pid" 2>/dev/null)

    if [ -n "$children" ]; then
        for child in $children; do
            # Add this child
            descendants="$descendants $child"
            # Recursively get its descendants
            local sub_descendants=$(get_all_descendants "$child")
            if [ -n "$sub_descendants" ]; then
                descendants="$descendants$sub_descendants"
            fi
        done
    fi

    echo "$descendants"
}

# Main function to show all processes
show_processes() {
    # Get all sessions
    tmux list-sessions -F "#{session_name}" 2>/dev/null | while read -r session; do
    # First pass: collect all PIDs in this session to calculate totals
    session_pids=()
    tmux list-windows -t "$session" -F "#{window_index}" 2>/dev/null | while read -r win_idx; do
        tmux list-panes -t "$session:$win_idx" -F "#{pane_pid}" 2>/dev/null | while read -r pane_pid; do
            all_pids=$(get_all_descendants "$pane_pid")
            for pid in $all_pids; do
                echo "$pid"
            done
        done
    done > /tmp/tmux-session-pids-$$

    # Calculate session totals
    total_cpu=0
    total_mem_kb=0
    while read -r pid; do
        cpu=$(ps -p "$pid" -o %cpu= 2>/dev/null | xargs)
        mem=$(ps -p "$pid" -o rss= 2>/dev/null | xargs)
        [ -n "$cpu" ] && total_cpu=$(awk "BEGIN {printf \"%.1f\", $total_cpu + $cpu}")
        [ -n "$mem" ] && total_mem_kb=$((total_mem_kb + mem))
    done < /tmp/tmux-session-pids-$$
    rm -f /tmp/tmux-session-pids-$$

    # Format session totals
    if [ "$total_mem_kb" -lt 1024 ]; then
        total_mem_display="${total_mem_kb}K"
    elif [ "$total_mem_kb" -lt 1048576 ]; then
        total_mem_mb=$((total_mem_kb / 1024))
        total_mem_display="${total_mem_mb}M"
    else
        total_mem_gb=$(awk "BEGIN {printf \"%.1f\", $total_mem_kb/1048576}")
        total_mem_display="${total_mem_gb}G"
    fi

    # Color code session totals
    cpu_int=$(printf "%.0f" "$total_cpu")
    if [ "$cpu_int" -lt 20 ]; then
        session_cpu_color="\033[32m"  # Green
    elif [ "$cpu_int" -lt 100 ]; then
        session_cpu_color="\033[33m"  # Yellow
    else
        session_cpu_color="\033[31m"  # Red
    fi

    if [ "$total_mem_kb" -lt 512000 ]; then
        session_mem_color="\033[32m"  # Green < 500M
    elif [ "$total_mem_kb" -lt 2048000 ]; then
        session_mem_color="\033[33m"  # Yellow < 2G
    else
        session_mem_color="\033[31m"  # Red >= 2G
    fi
    reset_color="\033[0m"

    # Bold session name with totals
    session_totals="${session_cpu_color}${total_cpu}%${reset_color}/${session_mem_color}${total_mem_display}${reset_color}"
    echo -e "\033[1mSession: $session\033[0m [$session_totals]"

    # Get all windows in this session
    tmux list-windows -t "$session" -F "#{window_index}:#{window_name}" | while read -r window_info; do
        window_index="${window_info%%:*}"
        window_name="${window_info#*:}"

        # Get all panes in this window
        tmux list-panes -t "$session:$window_index" -F "#{pane_index} #{pane_pid}" | while read -r pane_index pane_pid; do
            # Get ALL descendants of the pane's shell (not just direct children)
            all_pids=$(get_all_descendants "$pane_pid")

            # Collect pane statistics
            pane_process_count=0
            pane_cpu_total=0
            pane_mem_total=0
            declare -a pane_processes=()

            if [ -n "$all_pids" ]; then
                # First pass: collect all process info
                for pid in $all_pids; do
                    # Get process info - use separate ps calls for reliability
                    process_name=$(ps -p "$pid" -o comm= 2>/dev/null | xargs)
                    cpu_percent=$(ps -p "$pid" -o %cpu= 2>/dev/null | xargs)
                    mem_kb=$(ps -p "$pid" -o rss= 2>/dev/null | xargs)
                    process_cmd=$(ps -p "$pid" -o args= 2>/dev/null)

                    if [ -z "$process_name" ]; then
                        continue
                    fi

                    # Ensure numeric values
                    [ -z "$cpu_percent" ] && cpu_percent="0.0"
                    [ -z "$mem_kb" ] && mem_kb="0"

                    # Add to pane totals
                    pane_process_count=$((pane_process_count + 1))
                    pane_cpu_total=$(awk "BEGIN {printf \"%.1f\", $pane_cpu_total + $cpu_percent}")
                    pane_mem_total=$((pane_mem_total + mem_kb))

                    # Convert memory to human-readable format
                    if [ "$mem_kb" -lt 1024 ]; then
                        mem_display="${mem_kb}K"
                    elif [ "$mem_kb" -lt 1048576 ]; then
                        mem_mb=$((mem_kb / 1024))
                        mem_display="${mem_mb}M"
                    else
                        mem_gb=$(awk "BEGIN {printf \"%.1f\", $mem_kb/1048576}")
                        mem_display="${mem_gb}G"
                    fi

                    # Color coding for CPU (green < 10%, yellow < 50%, red >= 50%)
                    cpu_int=$(printf "%.0f" "$cpu_percent")
                    cpu_status="green"
                    if [ "$cpu_int" -lt 10 ]; then
                        cpu_color="\033[32m"  # Green
                    elif [ "$cpu_int" -lt 50 ]; then
                        cpu_color="\033[33m"  # Yellow
                        cpu_status="yellow"
                    else
                        cpu_color="\033[31m"  # Red
                        cpu_status="red"
                    fi

                    # Color coding for MEM (green < 100M, yellow < 500M, red >= 500M)
                    mem_status="green"
                    if [ "$mem_kb" -lt 102400 ]; then
                        mem_color="\033[32m"  # Green
                    elif [ "$mem_kb" -lt 512000 ]; then
                        mem_color="\033[33m"  # Yellow
                        mem_status="yellow"
                    else
                        mem_color="\033[31m"  # Red
                        mem_status="red"
                    fi
                    reset_color="\033[0m"

                    # Truncate long process names (just show basename if it's a path)
                    if [[ "$process_name" == /* ]] && [ ${#process_name} -gt 20 ]; then
                        process_name=$(basename "$process_name")
                    fi
                    # Limit process name to 20 chars
                    if [ ${#process_name} -gt 20 ]; then
                        process_name="${process_name:0:17}..."
                    fi

                    # Format resource usage
                    resources="${cpu_color}${cpu_percent}%${reset_color}/${mem_color}${mem_display}${reset_color}"

                    # Calculate available space for command
                    # Format: "  └─ PID 12345 5.2%/234M (process_name) - command"
                    # Account for color codes (they don't display but are in string)
                    display_resources="${cpu_percent}%/${mem_display}"
                    prefix_len=$((10 + ${#pid} + 1 + ${#display_resources} + 3 + ${#process_name} + 3))
                    max_cmd_len=$((100 - prefix_len))

                    # Ensure minimum command length and cap at reasonable max
                    [ $max_cmd_len -lt 20 ] && max_cmd_len=20
                    [ $max_cmd_len -gt 50 ] && max_cmd_len=50

                    # Truncate command to calculated length
                    if [ ${#process_cmd} -gt $max_cmd_len ]; then
                        process_cmd="${process_cmd:0:$((max_cmd_len - 3))}..."
                    fi

                    # Store process info
                    process_line="  └─ PID $pid $resources ($process_name) - $process_cmd"
                    pane_processes+=("$cpu_status|$mem_status|$process_line")
                done

                # Format pane totals
                if [ "$pane_mem_total" -lt 1024 ]; then
                    pane_mem_display="${pane_mem_total}K"
                elif [ "$pane_mem_total" -lt 1048576 ]; then
                    pane_mem_mb=$((pane_mem_total / 1024))
                    pane_mem_display="${pane_mem_mb}M"
                else
                    pane_mem_gb=$(awk "BEGIN {printf \"%.1f\", $pane_mem_total/1048576}")
                    pane_mem_display="${pane_mem_gb}G"
                fi

                # Color code pane totals
                pane_cpu_int=$(printf "%.0f" "$pane_cpu_total")
                if [ "$pane_cpu_int" -lt 10 ]; then
                    pane_cpu_color="\033[32m"
                elif [ "$pane_cpu_int" -lt 50 ]; then
                    pane_cpu_color="\033[33m"
                else
                    pane_cpu_color="\033[31m"
                fi

                if [ "$pane_mem_total" -lt 102400 ]; then
                    pane_mem_color="\033[32m"
                elif [ "$pane_mem_total" -lt 512000 ]; then
                    pane_mem_color="\033[33m"
                else
                    pane_mem_color="\033[31m"
                fi

                # Print pane header with summary
                pane_summary="${pane_cpu_color}${pane_cpu_total}%${reset_color}/${pane_mem_color}${pane_mem_display}${reset_color}"
                echo -e "Window $window_index ($window_name) Pane $pane_index [$pane_process_count processes, $pane_summary]"

                # Print processes
                if [ "$COMPACT_MODE" = true ]; then
                    # Only show yellow/red processes
                    for proc_info in "${pane_processes[@]}"; do
                        cpu_stat="${proc_info%%|*}"
                        rest="${proc_info#*|}"
                        mem_stat="${rest%%|*}"
                        proc_line="${rest#*|}"

                        if [ "$cpu_stat" != "green" ] || [ "$mem_stat" != "green" ]; then
                            echo -e "$proc_line"
                        fi
                    done
                else
                    # Show all processes
                    for proc_info in "${pane_processes[@]}"; do
                        proc_line="${proc_info#*|*|}"
                        echo -e "$proc_line"
                    done
                fi
            else
                # No child processes, just the shell
                process_name=$(ps -p "$pane_pid" -o comm= 2>/dev/null | xargs)
                if [ -n "$process_name" ]; then
                    cpu_percent=$(ps -p "$pane_pid" -o %cpu= 2>/dev/null | xargs)
                    mem_kb=$(ps -p "$pane_pid" -o rss= 2>/dev/null | xargs)

                    # Ensure numeric values
                    [ -z "$cpu_percent" ] && cpu_percent="0.0"
                    [ -z "$mem_kb" ] && mem_kb="0"

                    # Convert memory to human-readable
                    if [ "$mem_kb" -lt 1024 ]; then
                        mem_display="${mem_kb}K"
                    else
                        mem_mb=$((mem_kb / 1024))
                        mem_display="${mem_mb}M"
                    fi

                    # Idle shells typically have very low usage (green)
                    cpu_color="\033[32m"
                    mem_color="\033[32m"
                    reset_color="\033[0m"

                    resources="${cpu_color}${cpu_percent}%${reset_color}/${mem_color}${mem_display}${reset_color}"

                    # Print pane header with idle shell summary
                    echo -e "Window $window_index ($window_name) Pane $pane_index [1 process, $resources]"

                    # In compact mode, idle shells are never shown (always green)
                    if [ "$COMPACT_MODE" != true ]; then
                        echo -e "  └─ PID $pane_pid $resources ($process_name) [idle shell]"
                    fi
                fi
            fi
        done
    done
    echo ""
    done
}

# Run in watch mode or once
if [ "$WATCH_MODE" = true ]; then
    while true; do
        clear
        echo "tmux-ps - Updated: $(date '+%Y-%m-%d %H:%M:%S') - Refresh: ${INTERVAL}s - Press Ctrl+C to exit"
        echo ""
        show_processes
        sleep "$INTERVAL"
    done
else
    show_processes
fi
