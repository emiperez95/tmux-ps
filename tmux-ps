#!/usr/bin/env bash
# Simple tmux session and process listing

# Parse arguments
COMPACT_MODE=false
ULTRACOMPACT_MODE=false
WATCH_MODE=false
INTERVAL=2
FILTER=""
PROFILE_MODE=false

while [[ $# -gt 0 ]]; do
    case "$1" in
        --compact|-c)
            COMPACT_MODE=true
            shift
            ;;
        --ultracompact|-u)
            ULTRACOMPACT_MODE=true
            COMPACT_MODE=true  # Ultracompact implies compact
            shift
            ;;
        --filter|-f)
            if [ -z "$2" ]; then
                echo "Error: --filter requires a pattern argument"
                exit 1
            fi
            FILTER="$2"
            shift 2
            ;;
        --profile)
            PROFILE_MODE=true
            shift
            ;;
        --watch|-w)
            WATCH_MODE=true
            # Check if next arg is a number (interval)
            if [[ "$2" =~ ^[0-9]+$ ]]; then
                INTERVAL="$2"
                shift
            fi
            shift
            ;;
        --help|-h)
            echo "Usage: tmux-ps [OPTIONS]"
            echo ""
            echo "Options:"
            echo "  -c, --compact         Show only high-resource processes (yellow/red)"
            echo "  -u, --ultracompact    Show only sessions with >2% CPU or >100MB RAM"
            echo "  -f, --filter PATTERN  Show only sessions matching pattern (case-insensitive)"
            echo "  -w, --watch [N]       Refresh every N seconds (default: 2)"
            echo "  -h, --help            Show this help message"
            echo ""
            echo "Examples:"
            echo "  tmux-ps                    # Show all processes once"
            echo "  tmux-ps --compact          # Show only problem processes"
            echo "  tmux-ps --ultracompact     # Show only busy sessions"
            echo "  tmux-ps -f worktree        # Show only sessions with 'worktree' in name"
            echo "  tmux-ps --watch            # Refresh every 2 seconds"
            echo "  tmux-ps -w 5 -u -f gene    # Ultracompact + filter + watch"
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            echo "Run 'tmux-ps --help' for usage information"
            exit 1
            ;;
    esac
done

# Trap Ctrl+C for clean exit
trap 'echo ""; exit 0' INT

# Profiling helpers
PROFILE_FILE="/tmp/tmux-ps-profile-$$"

profile_start() {
    [ "$PROFILE_MODE" != true ] && return
    echo "$1 start $(date +%s%N)" >> "$PROFILE_FILE"
}

profile_end() {
    [ "$PROFILE_MODE" != true ] && return
    echo "$1 end $(date +%s%N)" >> "$PROFILE_FILE"
}

profile_summary() {
    [ "$PROFILE_MODE" != true ] && return
    [ ! -f "$PROFILE_FILE" ] && return

    echo ""
    echo "=== PROFILING SUMMARY ==="
    echo ""
    printf "%-30s %10s %10s %10s\n" "Operation" "Calls" "Total(ms)" "Avg(ms)"
    printf "%-30s %10s %10s %10s\n" "----------" "-----" "---------" "--------"

    # Process profiling data
    awk '
    {
        name = $1
        action = $2
        time = $3

        if (action == "start") {
            start_times[name] = time
        } else if (action == "end" && start_times[name]) {
            elapsed = (time - start_times[name]) / 1000000  # Convert to ms
            totals[name] += elapsed
            counts[name]++
            delete start_times[name]
        }
    }
    END {
        for (name in totals) {
            count = counts[name]
            total = totals[name]
            avg = (count > 0) ? total / count : 0
            printf "%-30s %10d %10d %10d\n", name, count, total, avg
        }
    }
    ' "$PROFILE_FILE" | sort -k3 -rn

    echo ""
    rm -f "$PROFILE_FILE"
}

# Function to recursively get all descendant PIDs
get_all_descendants() {
    profile_start "get_all_descendants"
    local parent_pid=$1
    local descendants=""

    # Get direct children
    profile_start "pgrep_calls"
    local children=$(pgrep -P "$parent_pid" 2>/dev/null)
    profile_end "pgrep_calls"

    if [ -n "$children" ]; then
        for child in $children; do
            # Add this child
            descendants="$descendants $child"
            # Recursively get its descendants
            local sub_descendants=$(get_all_descendants "$child")
            if [ -n "$sub_descendants" ]; then
                descendants="$descendants$sub_descendants"
            fi
        done
    fi

    echo "$descendants"
    profile_end "get_all_descendants"
}

# Helper function to get process info from cache
get_process_info() {
    profile_start "get_process_info"
    local pid=$1
    local cache_file=$2
    # Lookup PID in cache: PID|CPU|MEM|COMM|ARGS
    profile_start "grep_calls"
    local result=$(grep "^$pid|" "$cache_file" 2>/dev/null)
    profile_end "grep_calls"
    echo "$result"
    profile_end "get_process_info"
}

# Main function to show all processes
show_processes() {
    profile_start "total_runtime"

    # Cache all process info with ONE ps call for performance
    # Format: PID|CPU|MEM|COMM|ARGS
    profile_start "ps_cache_build"
    local process_cache="/tmp/tmux-ps-cache-$$"
    ps -eo pid=,%cpu=,rss=,comm=,args= 2>/dev/null | awk '{
        pid=$1; cpu=$2; mem=$3; comm=$4
        $1=$2=$3=$4=""
        args=$0
        sub(/^[ \t]+/, "", args)
        print pid "|" cpu "|" mem "|" comm "|" args
    }' > "$process_cache"
    profile_end "ps_cache_build"

    # Cleanup cache on exit
    trap "rm -f $process_cache" EXIT

    # Get all sessions
    profile_start "session_processing"
    tmux list-sessions -F "#{session_name}" 2>/dev/null | while read -r session; do
        # Apply filter if specified (case-insensitive)
        if [ -n "$FILTER" ]; then
            if ! echo "$session" | grep -iq "$FILTER"; then
                continue  # Skip this session
            fi
        fi

        # First pass: collect all PIDs in this session to calculate totals
    session_pids=()
    tmux list-windows -t "$session" -F "#{window_index}" 2>/dev/null | while read -r win_idx; do
        tmux list-panes -t "$session:$win_idx" -F "#{pane_pid}" 2>/dev/null | while read -r pane_pid; do
            all_pids=$(get_all_descendants "$pane_pid")
            for pid in $all_pids; do
                echo "$pid"
            done
        done
    done > /tmp/tmux-session-pids-$$

    # Calculate session totals
    profile_start "session_totals"
    total_cpu=0
    total_mem_kb=0
    while read -r pid; do
        info=$(get_process_info "$pid" "$process_cache")
        if [ -n "$info" ]; then
            cpu=$(echo "$info" | cut -d'|' -f2)
            mem=$(echo "$info" | cut -d'|' -f3)
            [ -n "$cpu" ] && total_cpu=$(awk "BEGIN {printf \"%.1f\", $total_cpu + $cpu}")
            [ -n "$mem" ] && total_mem_kb=$((total_mem_kb + mem))
        fi
    done < /tmp/tmux-session-pids-$$
    rm -f /tmp/tmux-session-pids-$$
    profile_end "session_totals"

    # Format session totals
    if [ "$total_mem_kb" -lt 1024 ]; then
        total_mem_display="${total_mem_kb}K"
    elif [ "$total_mem_kb" -lt 1048576 ]; then
        total_mem_mb=$((total_mem_kb / 1024))
        total_mem_display="${total_mem_mb}M"
    else
        total_mem_gb=$(awk "BEGIN {printf \"%.1f\", $total_mem_kb/1048576}")
        total_mem_display="${total_mem_gb}G"
    fi

    # Color code session totals
    cpu_int=$(printf "%.0f" "$total_cpu")
    if [ "$cpu_int" -lt 20 ]; then
        session_cpu_color="\033[32m"  # Green
    elif [ "$cpu_int" -lt 100 ]; then
        session_cpu_color="\033[33m"  # Yellow
    else
        session_cpu_color="\033[31m"  # Red
    fi

    if [ "$total_mem_kb" -lt 512000 ]; then
        session_mem_color="\033[32m"  # Green < 500M
    elif [ "$total_mem_kb" -lt 2048000 ]; then
        session_mem_color="\033[33m"  # Yellow < 2G
    else
        session_mem_color="\033[31m"  # Red >= 2G
    fi
    reset_color="\033[0m"

    # In ultracompact mode, skip sessions below threshold
    if [ "$ULTRACOMPACT_MODE" = true ]; then
        # Skip if CPU <= 2% AND memory <= 100MB (102400 KB)
        cpu_check=$(awk "BEGIN {print ($total_cpu > 2.0) ? 1 : 0}")
        mem_check=$((total_mem_kb > 102400 ? 1 : 0))

        if [ "$cpu_check" -eq 0 ] && [ "$mem_check" -eq 0 ]; then
            continue  # Skip this session entirely
        fi
    fi

    # Bold session name with totals
    session_totals="${session_cpu_color}${total_cpu}%${reset_color}/${session_mem_color}${total_mem_display}${reset_color}"
    echo -e "\033[1mSession: $session\033[0m [$session_totals]"

    # Get all windows in this session
    tmux list-windows -t "$session" -F "#{window_index}:#{window_name}" | while read -r window_info; do
        window_index="${window_info%%:*}"
        window_name="${window_info#*:}"

        # Get all panes in this window
        tmux list-panes -t "$session:$window_index" -F "#{pane_index} #{pane_pid}" | while read -r pane_index pane_pid; do
            # Get ALL descendants of the pane's shell (not just direct children)
            all_pids=$(get_all_descendants "$pane_pid")

            # Collect pane statistics
            pane_process_count=0
            pane_cpu_total=0
            pane_mem_total=0
            declare -a pane_processes=()

            if [ -n "$all_pids" ]; then
                # First pass: collect all process info
                for pid in $all_pids; do
                    # Get process info from cache (already loaded at start)
                    info=$(get_process_info "$pid" "$process_cache")
                    if [ -z "$info" ]; then
                        continue
                    fi

                    # Parse: PID|CPU|MEM|COMM|ARGS
                    cpu_percent=$(echo "$info" | cut -d'|' -f2)
                    mem_kb=$(echo "$info" | cut -d'|' -f3)
                    process_name=$(echo "$info" | cut -d'|' -f4)
                    process_cmd=$(echo "$info" | cut -d'|' -f5-)

                    # Ensure numeric values
                    [ -z "$cpu_percent" ] && cpu_percent="0.0"
                    [ -z "$mem_kb" ] && mem_kb="0"

                    # Add to pane totals
                    pane_process_count=$((pane_process_count + 1))
                    pane_cpu_total=$(awk "BEGIN {printf \"%.1f\", $pane_cpu_total + $cpu_percent}")
                    pane_mem_total=$((pane_mem_total + mem_kb))

                    # Convert memory to human-readable format
                    if [ "$mem_kb" -lt 1024 ]; then
                        mem_display="${mem_kb}K"
                    elif [ "$mem_kb" -lt 1048576 ]; then
                        mem_mb=$((mem_kb / 1024))
                        mem_display="${mem_mb}M"
                    else
                        mem_gb=$(awk "BEGIN {printf \"%.1f\", $mem_kb/1048576}")
                        mem_display="${mem_gb}G"
                    fi

                    # Color coding for CPU (green < 10%, yellow < 50%, red >= 50%)
                    cpu_int=$(printf "%.0f" "$cpu_percent")
                    cpu_status="green"
                    if [ "$cpu_int" -lt 10 ]; then
                        cpu_color="\033[32m"  # Green
                    elif [ "$cpu_int" -lt 50 ]; then
                        cpu_color="\033[33m"  # Yellow
                        cpu_status="yellow"
                    else
                        cpu_color="\033[31m"  # Red
                        cpu_status="red"
                    fi

                    # Color coding for MEM (green < 100M, yellow < 500M, red >= 500M)
                    mem_status="green"
                    if [ "$mem_kb" -lt 102400 ]; then
                        mem_color="\033[32m"  # Green
                    elif [ "$mem_kb" -lt 512000 ]; then
                        mem_color="\033[33m"  # Yellow
                        mem_status="yellow"
                    else
                        mem_color="\033[31m"  # Red
                        mem_status="red"
                    fi
                    reset_color="\033[0m"

                    # Truncate long process names (just show basename if it's a path)
                    if [[ "$process_name" == /* ]] && [ ${#process_name} -gt 20 ]; then
                        process_name=$(basename "$process_name")
                    fi
                    # Limit process name to 20 chars
                    if [ ${#process_name} -gt 20 ]; then
                        process_name="${process_name:0:17}..."
                    fi

                    # Format resource usage
                    resources="${cpu_color}${cpu_percent}%${reset_color}/${mem_color}${mem_display}${reset_color}"

                    # Calculate available space for command
                    # Format: "  └─ PID 12345 5.2%/234M (process_name) - command"
                    # Account for color codes (they don't display but are in string)
                    display_resources="${cpu_percent}%/${mem_display}"
                    prefix_len=$((10 + ${#pid} + 1 + ${#display_resources} + 3 + ${#process_name} + 3))
                    max_cmd_len=$((100 - prefix_len))

                    # Ensure minimum command length and cap at reasonable max
                    [ $max_cmd_len -lt 20 ] && max_cmd_len=20
                    [ $max_cmd_len -gt 50 ] && max_cmd_len=50

                    # Truncate command to calculated length
                    if [ ${#process_cmd} -gt $max_cmd_len ]; then
                        process_cmd="${process_cmd:0:$((max_cmd_len - 3))}..."
                    fi

                    # Store process info
                    process_line="  └─ PID $pid $resources ($process_name) - $process_cmd"
                    pane_processes+=("$cpu_status|$mem_status|$process_line")
                done

                # Format pane totals
                if [ "$pane_mem_total" -lt 1024 ]; then
                    pane_mem_display="${pane_mem_total}K"
                elif [ "$pane_mem_total" -lt 1048576 ]; then
                    pane_mem_mb=$((pane_mem_total / 1024))
                    pane_mem_display="${pane_mem_mb}M"
                else
                    pane_mem_gb=$(awk "BEGIN {printf \"%.1f\", $pane_mem_total/1048576}")
                    pane_mem_display="${pane_mem_gb}G"
                fi

                # Color code pane totals
                pane_cpu_int=$(printf "%.0f" "$pane_cpu_total")
                if [ "$pane_cpu_int" -lt 10 ]; then
                    pane_cpu_color="\033[32m"
                elif [ "$pane_cpu_int" -lt 50 ]; then
                    pane_cpu_color="\033[33m"
                else
                    pane_cpu_color="\033[31m"
                fi

                if [ "$pane_mem_total" -lt 102400 ]; then
                    pane_mem_color="\033[32m"
                elif [ "$pane_mem_total" -lt 512000 ]; then
                    pane_mem_color="\033[33m"
                else
                    pane_mem_color="\033[31m"
                fi

                # Print pane header with summary
                pane_summary="${pane_cpu_color}${pane_cpu_total}%${reset_color}/${pane_mem_color}${pane_mem_display}${reset_color}"
                echo -e "Window $window_index ($window_name) Pane $pane_index [$pane_process_count processes, $pane_summary]"

                # Print processes
                if [ "$COMPACT_MODE" = true ]; then
                    # Only show yellow/red processes
                    for proc_info in "${pane_processes[@]}"; do
                        cpu_stat="${proc_info%%|*}"
                        rest="${proc_info#*|}"
                        mem_stat="${rest%%|*}"
                        proc_line="${rest#*|}"

                        if [ "$cpu_stat" != "green" ] || [ "$mem_stat" != "green" ]; then
                            echo -e "$proc_line"
                        fi
                    done
                else
                    # Show all processes
                    for proc_info in "${pane_processes[@]}"; do
                        proc_line="${proc_info#*|*|}"
                        echo -e "$proc_line"
                    done
                fi
            else
                # No child processes, just the shell
                info=$(get_process_info "$pane_pid" "$process_cache")
                if [ -n "$info" ]; then
                    cpu_percent=$(echo "$info" | cut -d'|' -f2)
                    mem_kb=$(echo "$info" | cut -d'|' -f3)
                    process_name=$(echo "$info" | cut -d'|' -f4)

                    # Ensure numeric values
                    [ -z "$cpu_percent" ] && cpu_percent="0.0"
                    [ -z "$mem_kb" ] && mem_kb="0"

                    # Convert memory to human-readable
                    if [ "$mem_kb" -lt 1024 ]; then
                        mem_display="${mem_kb}K"
                    else
                        mem_mb=$((mem_kb / 1024))
                        mem_display="${mem_mb}M"
                    fi

                    # Idle shells typically have very low usage (green)
                    cpu_color="\033[32m"
                    mem_color="\033[32m"
                    reset_color="\033[0m"

                    resources="${cpu_color}${cpu_percent}%${reset_color}/${mem_color}${mem_display}${reset_color}"

                    # Print pane header with idle shell summary
                    echo -e "Window $window_index ($window_name) Pane $pane_index [1 process, $resources]"

                    # In compact mode, idle shells are never shown (always green)
                    if [ "$COMPACT_MODE" != true ]; then
                        echo -e "  └─ PID $pane_pid $resources ($process_name) [idle shell]"
                    fi
                fi
            fi
        done
    done
    echo ""
    done
    profile_end "session_processing"
    profile_end "total_runtime"
    profile_summary
}

# Run in watch mode or once
if [ "$WATCH_MODE" = true ]; then
    while true; do
        clear
        echo "tmux-ps - Updated: $(date '+%Y-%m-%d %H:%M:%S') - Refresh: ${INTERVAL}s - Press Ctrl+C to exit"
        echo ""
        show_processes
        sleep "$INTERVAL"
    done
else
    show_processes
fi
